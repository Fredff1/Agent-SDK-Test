import random
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from pydantic import BaseModel

TInputItem = Dict[str, Any]

class ChatRequest(BaseModel):
	conversation_id: Optional[str] = None
	message: str

# agent message response
class MessageResponse(BaseModel):
	content: str
	agent: str

# agent event log of workflow
class AgentEvent(BaseModel):
	id: str
	type: str
	agent: str
	content: str
	metadata: Optional[Dict[str, Any]] = None
	timestamp: Optional[float] = None

# guardrail check input/output
class GuardrailCheck(BaseModel):
	id: str
	name: str
	input: str
	reasoning: str
	passed: bool
	timestamp: float
 
class FeedbackRequest(BaseModel):
    trace_id: str
    score: float
    comment: Optional[str] = None

#****************************************************************************************************
# ===================================================================================================
# Response Model： sending response back to frontend app
# Add fields, such as trace id for getting user feedback from frontend, fastapi app sending trace id
# generated by tracing agent run with langfuse， to frontend for display message with trace ID. 
# Traces can be scored in frontend app if obersavation platform allows multiple accesses simultaneously. 
# Otherwise，they can be sent back along with feedback values to backend for computing scores.
# ===================================================================================================
#****************************************************************************************************
class ChatResponse(BaseModel):
    conversation_id: str
    current_agent: str
    messages: List[MessageResponse]
    events: List[AgentEvent]
    context: Dict[str, Any] 
    agents: List[Dict[str, Any]]
    guardrails: List[GuardrailCheck] = []
    trace_id: Optional[str] = None

# =====================================================================
# In-memory store for conversation state 
# Session of OpenAI Agent SDK can also be used 
# In-memory store/session is used for multi-turn conversation 
# and agent orchestration (workflow), Commented by HCI2025
# =====================================================================

@dataclass
class ConversationState:
    input_items: List[TInputItem] = field(default_factory=list)
    current_agent_name: str = ""
    context: Dict[str, Any] = field(default_factory=dict)


class ConversationStore:
	def get(self, conversation_id: str) -> Optional[Dict[str, Any]]:
		pass

	def save(self, conversation_id: str, state: Dict[str, Any]):
		pass

class InMemoryConversationStore(ConversationStore):
#class InMemoryConversationStore():
	_conversations: Dict[str, Dict[str, Any]] = {}

	def get(self, conversation_id: str) -> Optional[Dict[str, Any]]:
		return self._conversations.get(conversation_id)

	def save(self, conversation_id: str, state: Dict[str, Any]):
		self._conversations[conversation_id] = state