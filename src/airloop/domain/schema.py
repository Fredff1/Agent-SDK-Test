import random
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from pydantic import BaseModel

TInputItem = Dict[str, Any]

class ChatRequest(BaseModel):
	conversation_id: Optional[str] = None
	message: str

# agent message response
class MessageResponse(BaseModel):
	content: str
	agent: str

# agent event log of workflow
class AgentEvent(BaseModel):
	id: str
	type: str
	agent: str
	content: str
	metadata: Optional[Dict[str, Any]] = None
	timestamp: Optional[float] = None

# guardrail check input/output
class GuardrailCheck(BaseModel):
	id: str
	name: str
	input: str
	reasoning: str
	passed: bool
	timestamp: float
 
class FeedbackRequest(BaseModel):
    trace_id: str
    score: float
    comment: Optional[str] = None

#****************************************************************************************************
# ===================================================================================================
# Response Model： sending response back to frontend app
# Add fields, such as trace id for getting user feedback from frontend, fastapi app sending trace id
# generated by tracing agent run with langfuse， to frontend for display message with trace ID. 
# Traces can be scored in frontend app if obersavation platform allows multiple accesses simultaneously. 
# Otherwise，they can be sent back along with feedback values to backend for computing scores.
# ===================================================================================================
#****************************************************************************************************
class ChatResponse(BaseModel):
    conversation_id: str
    current_agent: str
    messages: List[MessageResponse]
    events: List[AgentEvent]
    context: Dict[str, Any] 
    agents: List[Dict[str, Any]]
    guardrails: List[GuardrailCheck] = []
    trace_id: Optional[str] = None

# =====================================================================
# In-memory store for conversation state 
# Session of OpenAI Agent SDK can also be used 
# In-memory store/session is used for multi-turn conversation 
# and agent orchestration (workflow), Commented by HCI2025
# =====================================================================

@dataclass
class _RoundStore:
    agent_name: str = ""
    input_items: List[Dict[str,str]] = field(default_factory=list)
    messages: List[Dict[str,str]] = field(default_factory=list)
    events: List[Any] = field(default_factory=list)
    trace_id: Optional[str] = None
    guardrails: List[Any] = field(default_factory=list)
    

@dataclass
class ConversationState:
    
    input_items: List[TInputItem] = field(default_factory=list)
    current_agent_name: str = ""
    context: Dict[str, Any] = field(default_factory=dict)
    round_counter: int = 0
    round_store: Dict[int, _RoundStore] = field(default_factory=dict)
    
    
    def _ensure_round(self):
        self.round_store[self.round_counter] = self.round_store.get(self.round_counter, _RoundStore() )
	

    def update_round(
        self, 
        agent_name: str, 
        trace_id: str,
        input_items: List[Dict[str,str]],
        messages: List[Dict[str,str]]=None,
        events: Optional[List[Any]]=None,
    ):
        if not events:
            events = []
        if not messages:
            messages = []
        self._ensure_round()
        self.round_store[self.round_counter].agent_name = agent_name
        self.round_store[self.round_counter].input_items = input_items
        self.round_store[self.round_counter].events.extend(events)
        self.round_store[self.round_counter].messages.extend(messages)
        self.round_store[self.round_counter].trace_id = trace_id
        
    def finish_round(self):
        self.round_counter += 1
        self._ensure_round()
        
    @property
    def messages(self):
        msgs = []
        for ri, store in self.round_store.items():
            msgs.extend(store.messages)
        return msgs
	

		
            


class ConversationStore:
	def get(self, conversation_id: str) -> Optional[ConversationState]:
		pass

	def save(self, conversation_id: str, state: ConversationState):
		pass

class InMemoryConversationStore(ConversationStore):
	_conversations: Dict[str, ConversationState] = {}

	def get(self, conversation_id: str) -> Optional[ConversationState]:
		return self._conversations.get(conversation_id)

	def save(self, conversation_id: str, state: ConversationState):
		self._conversations[conversation_id] = state
  
class PersistentConversationStore:
    # TODO Implement persistent store
	def get(self, conversation_id: str) -> Optional[ConversationState]:
		pass

	def save(self, conversation_id: str, state: ConversationState):
		pass